/* eslint-disable @typescript-eslint/no-require-imports */

const { createServer } = require('http');
const next = require('next');
const { Server } = require('socket.io');
const { createAdapter } = require('@socket.io/redis-adapter');
const Redis = require('ioredis');
require('dotenv').config();

// Configure environment
const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = Number(process.env.PORT) || 3000;

const REDIS_HOST = process.env.REDIS_HOST || '127.0.0.1';
const REDIS_PORT = Number(process.env.REDIS_PORT) || 6379;

// Initialize the Next.js app
// this is starting up next.js
const app = next({ dev, hostname, port });

// any web traffic like asking for a page load will be handled by next.js
const handle = app.getRequestHandler();

// wait for next.js to be ready before starting our server
app.prepare().then(() => {
  // creating an httpServer and passing all traffic to next.js to handle (like page loads)
  const httpServer = createServer(handle);

  // Initialize Socket.IO server and attach it to our HTTP server.
  // This allows Socket.IO to handle WebSocket connections on the same server that serves our Next.js app.
  const io = new Server(httpServer, {
    // you can tweak transports/cors here if needed
  });

  // Create ioredis clients for the Socket.IO Redis adapter
  const pubClient = new Redis({ host: REDIS_HOST, port: REDIS_PORT });
  const subClient = pubClient.duplicate();
  io.adapter(createAdapter(pubClient, subClient));

  // Redis client for app-level state (e.g., latest code per room)
  const stateRedis = pubClient; // reuse the same connection for simplicity
 
  setInterval(async () => {
    const activeGames = await stateRedis.smembers("activeGames");

    for (const gameId of activeGames) {
      const startedAt = Number(await stateRedis.get(`game:${gameId}:startedAt`));
      const duration = Number(await stateRedis.get(`game:${gameId}:duration`));

      if (Date.now() >= startedAt + duration) {
        io.to(gameId).emit("gameEnded");

        await stateRedis.srem("activeGames", gameId);
        await stateRedis.del(`game:${gameId}:startedAt`);
        await stateRedis.del(`game:${gameId}:duration`);
      }
    }
  }, 1000); // check every second

  const GAME_DURATION_MS = 5 * 60 * 1000; // 5 minutes in milliseconds

  // Listen for socket connections
  io.on('connection', (socket) => {
    // socket.id is a unique value for each client, auto-generated by socket.io
    console.log(`New connection: ${socket.id}`);

    // 1. Handle joining a specific game room
    socket.on('joinGame', async (gameId) => {
      await socket.join(gameId);

      // Determine how many people are currently in this specific room (cluster-aware)
      const socketsInRoom = await io.in(gameId).allSockets();
      const numPlayers = socketsInRoom ? socketsInRoom.size : 0;

      // Role Assignment Logic
      let role = 'spectator';
      if (numPlayers === 1) {
        role = 'coder'; // First person in
        socket.emit('waitingForTester'); // Notify the coder to wait for a tester
      } else if (numPlayers === 2) {
        role = 'tester'; // Second person in
        let startedAt = await stateRedis.get(`game:${gameId}:startedAt`);
        
        if (!startedAt) {

          startedAt = Date.now();
          await stateRedis.sadd("activeGames", gameId);
          await stateRedis.set(`game:${gameId}:startedAt`, Date.now());
          await stateRedis.set(`game:${gameId}:duration`, GAME_DURATION_MS);

          console.log(`Game ${gameId} started at ${new Date(Number(startedAt)).toISOString()} with duration ${GAME_DURATION_MS / 1000} seconds`);
        }

        io.to(gameId).emit('gameStarted', { start: startedAt, durat: GAME_DURATION_MS });
      }
      // Emit the assigned role back ONLY to the person who just joined
      socket.emit('roleAssigned', role);
      // TODO: update player/role assignment in postgres here. See CODEBAT-14 and CODEBAT-56

      // Send latest code state from Redis if present so the joiner syncs
      try {
        const latestCode = await stateRedis.get(`game:${gameId}:code`);
        if (latestCode != null) {
          socket.emit('receiveCodeUpdate', latestCode);
        }
      } catch (e) {
        console.error('Error fetching code from Redis', e);
      }

      console.log(`Socket ${socket.id} joined room ${gameId} as ${role}`);
    });

    // 2. Handle live code relay (Coder -> Server -> Tester)
    socket.on('codeChange', async (data) => {
      const { roomId, code } = data || {};
      if (!roomId) return;
      // console.log(`Server received code for room ${roomId}`);

      // Persist latest code state in Redis so all nodes/late joiners can get it
      try {
        await stateRedis.set(`game:${roomId}:code`, code);
      } catch (e) {
        console.error('Error saving code to Redis', e);
      }

      // Broadcast the updated code to everyone else in the same room (except the sender)
      socket.to(roomId).emit('receiveCodeUpdate', code);
    });

    socket.on('sendChat', async (data) => {
      const { roomId, message } = data || {};
      if (!roomId || !message) return;

      // Broadcast the chat message to everyone else in the same room (except the sender)
      socket.to(roomId).emit('receiveChat', message);
    });

    // 3. Handle graceful disconnection
    socket.on('disconnect', () => {
      console.log(`Disconnected: ${socket.id}`);
    });
  });

  // Start the unified server
  httpServer.listen(port, () => {
    console.log(
      `Code BattleGrounds Server Ready on http://${hostname}:${port} (Redis @ ${REDIS_HOST}:${REDIS_PORT})`
    );
  });
});